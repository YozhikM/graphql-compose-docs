---
id: version-8.x.x-InputTypeComposer
title: InputTypeComposer
custom_edit_url: https://github.com/graphql-compose/graphql-compose/blob/master/src/InputTypeComposer.d.ts
original_id: InputTypeComposer
---

<!-- 
ðŸ›‘ðŸ›‘ðŸ›‘
DO NOT EDIT THIS FILE!
IT WAS AUTO-GENERATED FROM d.ts FILE
ðŸ›‘ðŸ›‘ðŸ›‘
If you want to make changes in this file, please do it via
https://github.com/graphql-compose/graphql-compose/blob/master/src/InputTypeComposer.d.ts
-->

## Static methods

### static create()

```js
static create<TCtx = any>(
  typeDef: InputTypeComposerDefinition,
  schemaComposer: SchemaComposer<TCtx>
): InputTypeComposer<TCtx>
```

Create `InputTypeComposer` with adding it by name to the `SchemaComposer`.

### static createTemp()

```js
static createTemp<TCtx = any>(
  typeDef: InputTypeComposerDefinition,
  schemaComposer: SchemaComposer<TCtx>
): InputTypeComposer<TCtx>
```

Create `InputTypeComposer` without adding it to the `SchemaComposer`. This method may be useful in plugins, when you need to create type temporary.

## Getters

### List

```js
List: ListComposer<InputTypeComposer<TContext>>;
```

Get Type wrapped in List modifier

```js
const UserTC = schemaComposer.createInputTC(`input UserInput { name: String }`);
schemaComposer.Mutation.addFields({
  add: {
    args: {
      users1: UserTC.List, // in SDL: users1: [UserInput]
      users2: UserTC.NonNull.List, // in SDL: users2: [UserInput!]
      users3: UserTC.NonNull.List.NonNull // in SDL: users2: [UserInput!]!
    }
  }
});
```

### NonNull

```js
NonNull: NonNullComposer<InputTypeComposer<TContext>>;
```

Get Type wrapped in NonNull modifier

```js
const UserTC = schemaComposer.createInputTC(`input UserInput { name: String }`);
schemaComposer.Mutation.addFields({
  add: {
    args: {
      users1: UserTC.List, // in SDL: users1: [UserInput]
      users2: UserTC.NonNull.List, // in SDL: users2: [UserInput!]
      users3: UserTC.NonNull.List.NonNull // in SDL: users2: [UserInput!]!
    }
  }
});
```

## Properties

### schemaComposer

```js
schemaComposer: SchemaComposer<TContext>;
```

## Field methods

### getFields()

```js
getFields(): InputTypeComposerFieldConfigMap
```

### getFieldNames()

```js
getFieldNames(): string[]
```

### hasField()

```js
hasField(
  fieldName: string
): boolean
```

### setFields()

```js
setFields(
  fields: InputTypeComposerFieldConfigMapDefinition
): this
```

### setField()

```js
setField(
  fieldName: string,
  fieldConfig: InputTypeComposerFieldConfigDefinition
): this
```

### addFields()

```js
addFields(
  newFields: InputTypeComposerFieldConfigMapDefinition
): this
```

Add new fields or replace existed in a GraphQL type

### addNestedFields()

```js
addNestedFields(
  newFields: InputTypeComposerFieldConfigMapDefinition
): this
```

Add new fields or replace existed (where field name may have dots)

### getField()

```js
getField(
  fieldName: string
): InputTypeComposerFieldConfig
```

### removeField()

```js
removeField(
  fieldNameOrArray: string | string[]
): this
```

Remove fields from type by name or array of names.
You also may pass name in dot-notation, in such case will be removed nested field.

```js
removeField('field1'); // remove 1 field
removeField(['field1', 'field2']); // remove 2 fields
removeField('field1.subField1'); // remove 1 nested field
```

### removeOtherFields()

```js
removeOtherFields(
  fieldNameOrArray: string | string[]
): this
```

### extendField()

```js
extendField(
  fieldName: string,
  partialFieldConfig: Partial<InputTypeComposerFieldConfigAsObjectDefinition>
): this
```

### reorderFields()

```js
reorderFields(
  names: string[]
): this
```

### getFieldConfig()

```js
getFieldConfig(
  fieldName: string
): GraphQLInputFieldConfig
```

### getFieldType()

```js
getFieldType(
  fieldName: string
): GraphQLInputType
```

### getFieldTypeName()

```js
getFieldTypeName(
  fieldName: string
): string
```

### getFieldTC()

```js
getFieldTC(
  fieldName: string
): ComposeNamedInputType<TContext>
```

Automatically unwrap from List, NonNull, ThunkComposer
It's important! Cause greatly helps to modify fields types in a real code
without manual unwrap writing.

If you need to work with wrappers, you may use the following code:
   - `TC.getField().type` // returns real wrapped TypeComposer
   - `TC.isFieldNonNull()` // checks is field NonNull or not
   - `TC.makeFieldNonNull()` // for wrapping in NonNullComposer
   - `TC.makeFieldNullable()` // for unwrapping from NonNullComposer
   - `TC.isFieldPlural()` // checks is field wrapped in ListComposer or not
   - `TC.makeFieldPlural()` // for wrapping in ListComposer
   - `TC.makeFieldNonPlural()` // for unwrapping from ListComposer

### getFieldITC()

```js
getFieldITC(
  fieldName: string
): InputTypeComposer<TContext>
```

Alias for `getFieldTC()` but returns statically checked InputTypeComposer.
If field have other type then error will be thrown.

### isRequired()

```js
isRequired(
  fieldName: string
): boolean
```

### isFieldNonNull()

```js
isFieldNonNull(
  fieldName: string
): boolean
```

### makeFieldNonNull()

```js
makeFieldNonNull(
  fieldNameOrArray: string | string[]
): this
```

### makeRequired()

```js
makeRequired(
  fieldNameOrArray: string | string[]
): this
```

An alias for `makeFieldNonNull()`

### makeFieldNullable()

```js
makeFieldNullable(
  fieldNameOrArray: string | string[]
): this
```

### makeOptional()

```js
makeOptional(
  fieldNameOrArray: string | string[]
): this
```

An alias for `makeFieldNullable()`

### isFieldPlural()

```js
isFieldPlural(
  fieldName: string
): boolean
```

### makeFieldPlural()

```js
makeFieldPlural(
  fieldNameOrArray: string | string[]
): this
```

### makeFieldNonPlural()

```js
makeFieldNonPlural(
  fieldNameOrArray: string | string[]
): this
```

## Type methods

### getType()

```js
getType(): GraphQLInputObjectType
```

### getTypePlural()

```js
getTypePlural(): ListComposer<InputTypeComposer<TContext>>
```

### getTypeNonNull()

```js
getTypeNonNull(): NonNullComposer<InputTypeComposer<TContext>>
```

### getTypeName()

```js
getTypeName(): string
```

### setTypeName()

```js
setTypeName(
  name: string
): this
```

### getDescription()

```js
getDescription(): string
```

### setDescription()

```js
setDescription(
  description: string
): this
```

### clone()

```js
clone(
  newTypeNameOrTC: string | InputTypeComposer<any>
): InputTypeComposer<TContext>
```

You may clone this type with a new provided name as string.
Or you may provide a new TypeComposer which will get all cloned
settings from this type.

### cloneTo()

```js
cloneTo(
  anotherSchemaComposer: SchemaComposer<any>,
  cloneMap: Map<any, any>
): InputTypeComposer<any>
```

Clone this type to another SchemaComposer.
Also will be cloned all sub-types.

### merge()

```js
merge(
  type: GraphQLInputObjectType | InputTypeComposer<any>
): this
```

## Extensions methods

### getExtensions()

```js
getExtensions(): Extensions
```

### setExtensions()

```js
setExtensions(
  extensions: Extensions
): this
```

### extendExtensions()

```js
extendExtensions(
  extensions: Extensions
): this
```

### clearExtensions()

```js
clearExtensions(): this
```

### getExtension()

```js
getExtension(
  extensionName: string
): unknown
```

### hasExtension()

```js
hasExtension(
  extensionName: string
): boolean
```

### setExtension()

```js
setExtension(
  extensionName: string,
  value: unknown
): this
```

### removeExtension()

```js
removeExtension(
  extensionName: string
): this
```

### getFieldExtensions()

```js
getFieldExtensions(
  fieldName: string
): Extensions
```

### setFieldExtensions()

```js
setFieldExtensions(
  fieldName: string,
  extensions: Extensions
): this
```

### extendFieldExtensions()

```js
extendFieldExtensions(
  fieldName: string,
  extensions: Extensions
): this
```

### clearFieldExtensions()

```js
clearFieldExtensions(
  fieldName: string
): this
```

### getFieldExtension()

```js
getFieldExtension(
  fieldName: string,
  extensionName: string
): unknown
```

### hasFieldExtension()

```js
hasFieldExtension(
  fieldName: string,
  extensionName: string
): boolean
```

### setFieldExtension()

```js
setFieldExtension(
  fieldName: string,
  extensionName: string,
  value: unknown
): this
```

### removeFieldExtension()

```js
removeFieldExtension(
  fieldName: string,
  extensionName: string
): this
```

### getDirectives()

```js
getDirectives(): Array<ExtensionsDirective>
```

-----------------------------------------------
Directive methods

Directive methods are useful if you declare your schemas via SDL.
Users who actively use `graphql-tools` can open new abilities for writing
your own directive handlers.

If you create your schemas via config objects, then probably you
no need in `directives`. Instead directives better to use `extensions`.
-----------------------------------------------

### setDirectives()

```js
setDirectives(
  directives: Array<ExtensionsDirective>
): this
```

### getDirectiveNames()

```js
getDirectiveNames(): string[]
```

### getDirectiveByName()

```js
getDirectiveByName(
  directiveName: string
): DirectiveArgs | undefined
```

### getDirectiveById()

```js
getDirectiveById(
  idx: number
): DirectiveArgs | undefined
```

### getFieldDirectives()

```js
getFieldDirectives(
  fieldName: string
): Array<ExtensionsDirective>
```

### setFieldDirectives()

```js
setFieldDirectives(
  fieldName: string,
  directives: Array<ExtensionsDirective>
): this
```

### getFieldDirectiveNames()

```js
getFieldDirectiveNames(
  fieldName: string
): string[]
```

### getFieldDirectiveByName()

```js
getFieldDirectiveByName(
  fieldName: string,
  directiveName: string
): DirectiveArgs | undefined
```

### getFieldDirectiveById()

```js
getFieldDirectiveById(
  fieldName: string,
  idx: number
): DirectiveArgs | undefined
```

## Misc methods

### get()

```js
get(
  path: string | string[]
): TypeInPath<TContext> | void
```

### getNestedTCs()

```js
getNestedTCs(
  opts: {
      exclude?: string[] | null;
  },
  passedTypes: Set<NamedTypeComposer<any>>
): Set<NamedTypeComposer<any>>
```

Returns all types which are used inside the current type

### toSDL()

```js
toSDL(
  opts: SchemaPrinterOptions & {
      deep?: boolean;
      sortTypes?: boolean;
      exclude?: string[];
  }
): string
```

Prints SDL for current type. Or print with all used types if `deep: true` option was provided.

## Internal type definitions

### InputTypeComposerDefinition

```js
export type InputTypeComposerDefinition =
  | TypeAsString
  | TypeDefinitionString
  | InputTypeComposerAsObjectDefinition
  | Readonly<GraphQLInputObjectType>;
```

### InputTypeComposerAsObjectDefinition

```js
export type InputTypeComposerAsObjectDefinition = {
  name: string;
  fields: ThunkWithSchemaComposer<InputTypeComposerFieldConfigMapDefinition, SchemaComposer<any>>;
  description?: null | string;
  extensions?: Extensions;
};
```

### InputTypeComposerFieldConfigMap

```js
export type InputTypeComposerFieldConfigMap = ObjMap<InputTypeComposerFieldConfig>;
```

### InputTypeComposerFieldConfigMapDefinition

```js
export type InputTypeComposerFieldConfigMapDefinition = ObjMap<InputTypeComposerFieldConfigDefinition>;
```

### InputTypeComposerFieldConfigDefinition

```js
export type InputTypeComposerFieldConfigDefinition =
  | ThunkWithSchemaComposer<InputTypeComposerFieldConfigAsObjectDefinition, SchemaComposer<any>>
  | ThunkWithSchemaComposer<ComposeInputTypeDefinition, SchemaComposer<any>>;
```

### InputTypeComposerFieldConfigAsObjectDefinition

```js
export type InputTypeComposerFieldConfigAsObjectDefinition = {
  type: ThunkWithSchemaComposer<ComposeInputTypeDefinition, SchemaComposer<any>>;
  defaultValue?: unknown;
  description?: string | null;
  extensions?: Extensions | null;
  [key: string]: unknown;
};
```

### InputTypeComposerFieldConfig

```js
export type InputTypeComposerFieldConfig = {
  type: ComposeInputType;
  defaultValue?: unknown;
  description?: string | null;
  astNode?: InputValueDefinitionNode | null;
  extensions?: Extensions;
  [key: string]: unknown;
};
```

### InputTypeComposerThunked

```js
export type InputTypeComposerThunked<TContext> =
  | InputTypeComposer<TContext>
  | ThunkComposer<InputTypeComposer<TContext>, GraphQLInputType>;
```

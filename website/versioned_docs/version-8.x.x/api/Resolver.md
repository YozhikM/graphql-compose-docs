---
id: version-8.x.x-Resolver
title: Resolver
custom_edit_url: https://github.com/graphql-compose/graphql-compose/blob/master/src/Resolver.d.ts
original_id: Resolver
---

<!-- 
ðŸ›‘ðŸ›‘ðŸ›‘
DO NOT EDIT THIS FILE!
IT WAS AUTO-GENERATED FROM d.ts FILE
ðŸ›‘ðŸ›‘ðŸ›‘
If you want to make changes in this file, please do it via
https://github.com/graphql-compose/graphql-compose/blob/master/src/Resolver.d.ts
-->

The most interesting class in `graphql-compose`. The main goal of `Resolver` is to keep available resolve methods for Type and use them for building relation with other types.

## Properties

### schemaComposer

```js
schemaComposer: SchemaComposer<TContext>;
```

### type

```js
type: ComposeOutputType<TContext>;
```

### args

```js
args: ObjectTypeComposerArgumentConfigMap<any>;
```

### name

```js
name: string;
```

### displayName

```js
displayName: string | undefined;
```

### kind

```js
kind: ResolverKinds | undefined;
```

### description

```js
description: string | undefined;
```

### deprecationReason

```js
deprecationReason: string | null | undefined;
```

### projection

```js
projection: ProjectionType;
```

### parent

```js
parent: Resolver<TSource, TContext, any> | undefined;
```

### extensions

```js
extensions: Extensions | undefined;
```

### resolve

```js
resolve: ResolverRpCb<TSource, TContext, TArgs>;
```

## Output type methods

### getType()

```js
getType(): GraphQLOutputType
```

### getTypeName()

```js
getTypeName(): string
```

### getTypeComposer()

```js
getTypeComposer(): ComposeNamedOutputType<TContext>
```

### getOTC()

```js
getOTC(): ObjectTypeComposer<TReturn, TContext>
```

Almost alias for `getTypeComposer`, but returns only ObjectTypeComposer.
It will throw an error if resolver has another kind of type.

### setType()

```js
setType<TNewReturn>(
  typeDef: ThunkWithSchemaComposer<Readonly<ComposeOutputType<TContext>> | ComposeOutputTypeDefinition<TContext> | Readonly<Resolver<any, TContext, any>>, SchemaComposer<TContext>>
): Resolver<TSource, TContext, TArgs, TNewReturn>
```

## Args methods

### hasArg()

```js
hasArg(
  argName: string
): boolean
```

### getArg()

```js
getArg(
  argName: string
): ObjectTypeComposerArgumentConfig
```

### getArgConfig()

```js
getArgConfig(
  argName: string
): GraphQLArgumentConfig
```

### getArgType()

```js
getArgType(
  argName: string
): GraphQLInputType
```

### getArgTypeName()

```js
getArgTypeName(
  fieldName: string
): string
```

### getArgs()

```js
getArgs(): ObjectTypeComposerArgumentConfigMap<TArgs>
```

### getArgNames()

```js
getArgNames(): string[]
```

### setArgs()

```js
setArgs<TNewArgs>(
  args: ObjectTypeComposerArgumentConfigMapDefinition<TNewArgs>
): Resolver<TSource, TContext, TNewArgs>
```

### setArg()

```js
setArg(
  argName: string,
  argConfig: ObjectTypeComposerArgumentConfigDefinition
): this
```

### setArgType()

```js
setArgType(
  argName: string,
  typeDef: Thunk<ComposeInputTypeDefinition>
): this
```

### extendArg()

```js
extendArg(
  argName: string,
  partialArgConfig: Partial<ObjectTypeComposerArgumentConfigAsObjectDefinition>
): this
```

### addArgs()

```js
addArgs(
  newArgs: ObjectTypeComposerArgumentConfigMapDefinition<any>
): this
```

### removeArg()

```js
removeArg(
  argNameOrArray: string | string[]
): this
```

### removeOtherArgs()

```js
removeOtherArgs(
  argNameOrArray: string | string[]
): this
```

### reorderArgs()

```js
reorderArgs(
  names: string[]
): this
```

### getArgTC()

```js
getArgTC(
  argName: string
): ComposeNamedInputType<TContext>
```

### getArgITC()

```js
getArgITC(
  argName: string
): InputTypeComposer<TContext>
```

Alias for `getArgTC()` but returns statically checked InputTypeComposer.
If field have other type then error will be thrown.

### isArgNonNull()

```js
isArgNonNull(
  argName: string
): boolean
```

### makeArgNonNull()

```js
makeArgNonNull(
  argNameOrArray: string | string[]
): this
```

### makeRequired()

```js
makeRequired(
  argNameOrArray: string | string[]
): this
```

### makeArgNullable()

```js
makeArgNullable(
  argNameOrArray: string | string[]
): this
```

### makeOptional()

```js
makeOptional(
  argNameOrArray: string | string[]
): this
```

### isArgPlural()

```js
isArgPlural(
  argName: string
): boolean
```

### makeArgPlural()

```js
makeArgPlural(
  argNameOrArray: string | string[]
): this
```

### makeArgNonPlural()

```js
makeArgNonPlural(
  argNameOrArray: string | string[]
): this
```

### cloneArg()

```js
cloneArg(
  argName: string,
  newTypeName: string
): this
```

### addFilterArg()

```js
addFilterArg(
  opts: ResolverFilterArgConfigDefinition<TSource, TContext, TArgs>
): this
```

### addSortArg()

```js
addSortArg(
  opts: ResolverSortArgConfig<TSource, TContext, TArgs>
): this
```

## Resolve methods

### getResolve()

```js
getResolve(): ResolverRpCb<TSource, TContext, TArgs>
```

### setResolve()

```js
setResolve(
  resolve: ResolverRpCb<TSource, TContext, TArgs>
): this
```

## Wrap methods

### withMiddlewares()

```js
withMiddlewares(
  middlewares: Array<ResolverMiddleware<TSource, TContext, TArgs>>
): Resolver<TSource, TContext, TArgs>
```

You may construct a new resolver with wrapped logic:

```js
const log = [];

const mw1 = async (resolve, source, args, context, info) => {
  log.push('m1.before');
  const res = await resolve(source, args, context, info);
  log.push('m1.after');
  return res;
};

const mw2 = async (resolve, source, args, context, info) => {
  log.push('m2.before');
  const res = await resolve(source, args, context, info);
  log.push('m2.after');
  return res;
};

const newResolver = Resolver.withMiddlewares([mw1, mw2]);
await newResolver.resolve({});

expect(log).toEqual([
  'm1.before',
  'm2.before',
  'call resolve',
  'm2.after',
  'm1.after'
]);
```

### wrap()

```js
wrap<TNewSource, TNewArgs>(
  cb: ResolverWrapCb<TNewSource, TSource, TContext, TNewArgs, TArgs> | null,
  newResolverOpts: Partial<ResolverDefinition<TNewSource, TContext, TNewArgs>>
): Resolver<TNewSource, TContext, TNewArgs>
```

### wrapResolve()

```js
wrapResolve(
  cb: ResolverNextRpCb<TSource, TContext, TArgs>,
  wrapperName: string
): Resolver<TSource, TContext, TArgs>
```

### wrapArgs()

```js
wrapArgs<TNewArgs>(
  cb: (prevArgs: GraphQLFieldConfigArgumentMap) => ObjectTypeComposerArgumentConfigMapDefinition<TArgs>,
  wrapperName: string
): Resolver<TSource, TContext, TNewArgs>
```

### wrapCloneArg()

```js
wrapCloneArg(
  argName: string,
  newTypeName: string
): Resolver<TSource, TContext, TArgs>
```

### wrapType()

```js
wrapType(
  cb: (prevType: ComposeOutputType<TContext>) => ComposeOutputTypeDefinition<TContext>,
  wrapperName: string
): Resolver<TSource, TContext, TArgs>
```

## Misc methods

### getFieldConfig()

```js
getFieldConfig(
  opts: {
      projection?: ProjectionType;
  }
): GraphQLFieldConfig<TSource, TContext, TArgs>
```

### getFieldResolver()

```js
getFieldResolver(
  opts: {
      projection?: ProjectionType;
  }
): GraphQLFieldResolver<TSource, TContext, TArgs>
```

### getKind()

```js
getKind(): ResolverKinds | void
```

### setKind()

```js
setKind(
  kind: string
): this
```

### getDescription()

```js
getDescription(): string | undefined
```

### setDescription()

```js
setDescription(
  description: string | undefined
): this
```

### getDeprecationReason()

```js
getDeprecationReason(): string | undefined | null
```

### setDeprecationReason()

```js
setDeprecationReason(
  reason: string | undefined
): this
```

### get()

```js
get(
  path: string | string[]
): TypeInPath<TContext> | void
```

### clone()

```js
clone<TNewSource, TNewArgs>(
  opts: Partial<ResolverDefinition<TNewSource, TContext, TNewArgs>>
): Resolver<TNewSource, TContext, TNewArgs>
```

Clone this Resolver with overriding of some options.
Internally it just copies all properties.
But for `args` and `projection` it recreates objects with the same type & values (it allows to add or remove properties without affection old Resolver).

### cloneTo()

```js
cloneTo(
  anotherSchemaComposer: SchemaComposer<any>,
  cloneMap: Map<any, any>
): Resolver<any, any, any>
```

Clone this resolver to another SchemaComposer.
Also will be cloned all sub-types.

## Extensions methods

### getExtensions()

```js
getExtensions(): Extensions
```

### setExtensions()

```js
setExtensions(
  extensions: Extensions
): this
```

### extendExtensions()

```js
extendExtensions(
  extensions: Extensions
): this
```

### clearExtensions()

```js
clearExtensions(): this
```

### getExtension()

```js
getExtension(
  extensionName: string
): unknown
```

### hasExtension()

```js
hasExtension(
  extensionName: string
): boolean
```

### setExtension()

```js
setExtension(
  extensionName: string,
  value: unknown
): this
```

### removeExtension()

```js
removeExtension(
  extensionName: string
): this
```

## Debug methods

### getNestedName()

```js
getNestedName(): string
```

### toString()

```js
toString(
  colors: boolean
): string
```

### setDisplayName()

```js
setDisplayName(
  name: string
): this
```

### toDebugStructure()

```js
toDebugStructure(
  colors: boolean
): Record<string, any>
```

### debugExecTime()

```js
debugExecTime(): Resolver<TSource, TContext, TArgs>
```

### debugParams()

```js
debugParams(
  filterPaths: string | string[] | undefined | null,
  opts: ResolverDebugOpts
): Resolver<TSource, TContext, TArgs>
```

### debugPayload()

```js
debugPayload(
  filterPaths: string | string[] | undefined | null,
  opts: ResolverDebugOpts
): Resolver<TSource, TContext, TArgs>
```

### debug()

```js
debug(
  filterDotPaths: {
      params?: string | string[] | undefined | null;
      payload?: string | string[] | undefined | null;
  },
  opts: ResolverDebugOpts
): Resolver<TSource, TContext, TArgs>
```

## Internal type definitions

### ResolverKinds

```js
export type ResolverKinds = 'query' | 'mutation' | 'subscription';
```

### ResolverDefinition

```js
export type ResolverDefinition<TSource, TContext, TArgs = any> = {
  type?: ThunkWithSchemaComposer<
    | Readonly<ComposeOutputType<TContext>>
    | ComposeOutputTypeDefinition<TContext>
    | Readonly<Resolver<any, TContext, any>>,
    SchemaComposer<TContext>
  >;
  resolve?: ResolverRpCb<TSource, TContext, TArgs>;
  args?: ObjectTypeComposerArgumentConfigMapDefinition<TArgs>;
  name?: string;
  displayName?: string;
  kind?: ResolverKinds;
  description?: string;
  deprecationReason?: string | null;
  projection?: ProjectionType;
  parent?: Resolver<any, TContext, any>;
  extensions?: Extensions;
};
```

### ResolverResolveParams

```js
export type ResolverResolveParams<TSource, TContext, TArgs = any> = {
  source: TSource;
  args: TArgs;
  context: TContext;
  info: GraphQLResolveInfo;
  projection: Partial<ProjectionType>;
  [opt: string]: any;
};
```

### ResolverFilterArgFn

```js
export type ResolverFilterArgFn<TSource, TContext, TArgs = any> = (
  query: any,
  value: any,
  resolveParams: ResolverResolveParams<TSource, TContext, TArgs>
) => any;
```

### ResolverFilterArgConfigDefinition

```js
export type ResolverFilterArgConfigDefinition<TSource, TContext, TArgs = any> = {
  name: string;
  type: ComposeInputTypeDefinition;
  description?: string | null | void;
  query?: ResolverFilterArgFn<TSource, TContext, TArgs>;
  filterTypeNameFallback?: string;
  defaultValue?: any;
};
```

### ResolverSortArgFn

```js
export type ResolverSortArgFn<TSource, TContext, TArgs = any> = (
  resolveParams: ResolverResolveParams<TSource, TContext, TArgs>
) => any;
```

### ResolverSortArgConfig

```js
export type ResolverSortArgConfig<TSource, TContext, TArgs = any> = {
  name: string;
  sortTypeNameFallback?: string;
  value:
    | { [key: string]: any }
    | ResolverSortArgFn<TSource, TContext, TArgs>
    | string
    | number
    | boolean
    | any[];
  deprecationReason?: string | null;
  description?: string | null;
};
```

### ResolverWrapCb

```js
export type ResolverWrapCb<TNewSource, TPrevSource, TContext, TNewArgs = any, TPrevArgs = any> = (
  newResolver: Resolver<TNewSource, TContext, TNewArgs>,
  prevResolver: Resolver<TPrevSource, TContext, TPrevArgs>
) => Resolver<TNewSource, TContext, TNewArgs>;
```

### ResolverRpCb

```js
export type ResolverRpCb<TSource, TContext, TArgs = any> = (
  resolveParams: ResolverResolveParams<TSource, TContext, TArgs>
) => Promise<any> | any;
```

### ResolverNextRpCb

```js
export type ResolverNextRpCb<TSource, TContext, TArgs = any> = (
  next: ResolverRpCb<TSource, TContext, TArgs>
) => ResolverRpCb<TSource, TContext, TArgs>;
```

### ResolverDebugOpts

```js
export type ResolverDebugOpts = {
  showHidden?: boolean;
  depth?: number;
  colors?: boolean;
};
```

### ResolverMiddleware

```js
export type ResolverMiddleware<TSource, TContext, TArgs = any> = (
  resolve: (source: TSource, args: TArgs, context: TContext, info: GraphQLResolveInfo) => any,
  source: TSource,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => any;
```
